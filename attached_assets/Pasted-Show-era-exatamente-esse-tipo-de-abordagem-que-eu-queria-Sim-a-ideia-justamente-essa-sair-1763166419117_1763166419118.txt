Show, era exatamente esse tipo de abordagem que eu queria. ‚úÖ

Sim, a ideia √© justamente essa: sair do single-tenant (tudo em Afogados dentro do Supabase) para multi-tenant com isolamento total, onde:

- o Supabase fica como Control Plane (cities, modules, auth, etc.)
- o Neon fica como Data Plane (um banco por cidade)
- o c√≥digo passa a orquestrar cria√ß√£o de DB, schema e migra√ß√£o de dados por cidade/m√≥dulo.

üëç Sobre a sua abordagem, estou de acordo com todos os pontos:

1) Descoberta autom√°tica de schema no Supabase  
   - Faz todo sentido usar `information_schema` + `pg_catalog` para ler o schema real.  
   - Quero justamente evitar reescrever CREATE TABLE ‚Äúna m√£o‚Äù.  
   - Pode seguir nessa linha de gerar DDL compat√≠vel com o Neon.

2) Mapeamento modular em `server/migrations/config/modules.ts`  
   - Perfeito ter um arquivo mapeando m√≥dulos ‚Üí tabelas, algo como:

     ```ts
     export const MODULE_TABLES = {
       educacao: ['schools', 'students', 'teachers', 'school_classes', 'student_enrollments', 'ideb_data'],
       saude: ['health_units', 'appointments'],
       conteudo: ['news', 'events', 'stories', 'campaign_banners', 'gallery_albums'],
       // etc...
     };
     ```

   - Pode criar esse arquivo e deixar bem documentado, porque depois eu vou expandir para outros m√≥dulos.

3) Pools de conex√£o reutiliz√°veis  
   - Ok com essa estrutura:

     - `getSupabasePool()`       ‚Üí Supabase (schema + dados atuais)
     - `getNeonAdminPool()`      ‚Üí conex√£o administrativa do Neon para `CREATE DATABASE`
     - `getCityNeonPool(slug)`  ‚Üí DB espec√≠fico da cidade

   - Isso deixa o c√≥digo bem organizado e pronto para ser chamado depois pelo painel de gerenciamento.

4) Pipeline de migra√ß√£o  
   - Essa ideia de comandos est√° perfeita:

     - `npm run migrate:provision afogados-da-ingazeira`
       - cria o DB Neon da cidade (se ainda n√£o existir),
       - replica o schema,
       - migra os dados,
       - atualiza `cities.db_url`.

     - `npm run migrate:new-city zabele --modules=educacao,saude`
       - cria DB da nova cidade,
       - cria apenas as tabelas dos m√≥dulos habilitados,
       - sem migra√ß√£o de dados (cidade nova, come√ßa ‚Äúdo zero‚Äù).

   - Quero que esse fluxo de CLI fique bem redondinho, porque mais pra frente vamos acionar isso a partir de uma tela do painel (via API), ent√£o ter esses comandos claros ajuda muito.

5) Tratamento dos dados  
   - Perfeito:

     - Se as tabelas tiverem coluna `city_id`, filtrar por `city_id` da cidade de Afogados.
     - Se n√£o tiverem `city_id`, podemos assumir que hoje todos os dados pertencem a Afogados (porque s√≥ Afogados existe de fato).

   - A idempot√™ncia tamb√©m √© essencial:
     - checar se a tabela do Neon est√° vazia antes de migrar,
     - e nunca deletar nada autom√°tico do Supabase nesse primeiro momento (migra√ß√£o n√£o-destrutiva).

6) Estrutura de c√≥digo  
   - Essa estrutura proposta em `server/migrations/...` est√° √≥tima:

     ```text
     server/
       migrations/
         config/
           modules.ts              # M√≥dulos ‚Üí tabelas
           control-plane-tables.ts # Tabelas que sempre ficam no Supabase
         utils/
           connections.ts          # Pools de conex√£o
           schema-reader.ts        # L√™ schema do Supabase
           ddl-generator.ts        # Gera CREATE TABLE p/ Neon
           data-migrator.ts        # Copia dados tabela a tabela
         commands/
           provision-city.ts       # Provisiona nova cidade
           migrate-afogados.ts     # Migra√ß√£o inicial de Afogados
           enable-module.ts        # Habilita m√≥dulo para cidade
         index.ts
     ```

   - Pode seguir esse desenho que est√° bem alinhado com a arquitetura que eu quero.

7) Seguran√ßa  
   - Totalmente alinhado:

     - Todas as credentials em ENV vars.
     - Nunca expor `db_url` no frontend.
     - Logs por cidade/m√≥dulo/tabela e quantidade de registros migrados.
     - Nada de apagar dados no Supabase nessa fase: migra√ß√£o sempre n√£o-destrutiva.

üîê Sobre ENV VARs:

Eu vou configurar as seguintes vari√°veis de ambiente:

- `SUPABASE_DB_URL`
  - conex√£o para o banco Postgres do Supabase que hoje cont√©m:
    - a tabela `public.cities`
    - e todas as tabelas operacionais de Afogados.

- `NEON_ADMIN_URL`
  - conex√£o para o banco ‚Äúadmin‚Äù do projeto Neon, com permiss√£o de criar outros databases (`CREATE DATABASE`).
  - se voc√™ precisar de um formato espec√≠fico (por exemplo `postgres://user:pass@host/db?sslmode=require`), me diga que eu ajusto.

- `NEON_PROJECT_ID`
  - se voc√™ for usar a API REST do Neon, eu configuro tamb√©m esse ID do projeto.

- (opcional, se voc√™ achar √∫til)
  - `NEON_CITY_AFOGADOS_DB_URL` enquanto testamos:
    - se por algum motivo n√£o for poss√≠vel criar o DB via c√≥digo, podemos apontar direto para um DB j√° criado de Afogados no Neon, e focar na parte de cria√ß√£o de schema + migra√ß√£o de dados.

Pode assumir que eu vou configurar essas envs no ambiente server e que elas n√£o estar√£o dispon√≠veis no frontend.

‚úÖ Pode come√ßar a implementar essa pipeline a partir da cidade Afogados:
- Primeiro provisionar o DB Neon de Afogados,
- Depois gerar schema a partir das tabelas que voc√™ mapear nos m√≥dulos (educacao, saude, conteudo, etc.),
- Em seguida migrar os dados de Afogados,
- E por fim atualizar `public.cities.db_url` para essa conex√£o Neon.

Depois que isso estiver funcionando para Afogados, a gente parte para:
- provisionamento de novas cidades via `migrate:new-city`,
- enable de m√≥dulos via `enable-module.ts`,
- e na sequ√™ncia vamos voltar para o frontend do painel geral para acionar tudo isso pela interface.

Pode seguir em frente, estamos prontos para come√ßar. üöÄ
